package info.kwarc.mmt.api.web

import info.kwarc.mmt.api.modules.diagrams.InstallDiagram
import info.kwarc.mmt.api.{MPath, Path, presentation}
import info.kwarc.mmt.api.utils.{JSONString, URI}

object SyntaxPresenterServer {
  val pathPrefix: String = "syntax"
  /**
    * The query parameter in the URI to reference the element to syntax present.
    */
  private val elementPathKey: String = "element"

  /**
    * The query parameter to flag plain instead of syntax-highlighted output.
    */
  private val plainFlag: String = "plain"

  def getURIForDiagram(baseURI: URI, diag: MPath): URI = {
    (baseURI / (":" + SyntaxPresenterServer.pathPrefix)) ? (elementPathKey + "=" + diag)
  }
}

/**
  * Provides highlighted syntax presentation of arbitrary MMT elements at the URI
  * [[http://localhost:8080/:syntax?element=<path to some MMT element>]].
  *
  * The highlighting depends on the [[https://github.com/ComFreek/mmteditor MMT Online Tools]] being available
  * at the URI in ''mmtWebEditorEndpoint'' (private field on this class).
  *
  * You can also access a non-highlighted plain representation by supplying the ''plain'' flag:
  * [[http://localhost:8080/:syntax?element=<path to some MMT element>&plain]].
  *
  * Requests with element pointing to a DerivedModule with the [[InstallDiagram]] structural feature are special-cased:
  * there, instead of the DerivedModule being presented, all the outputs generated by the diagram feature are
  * presented.
  * As the outputs of diagram features are not yet persisted to mmt-omdoc, requesting the presentation of
  * such DerivedModules only works if you have elaborated them before (e.g. after building the containing
  * MMT file to mmt-omdoc).
  *
  * (NB: if you are running the MMT server at another address/port, read ''localhost:8080'' in your mind accordingly.)
  *
  * @example Suppose you have ''theory T = c: type ❙❚'' in one of your MMT files with namespace
  *          ''https://example.com''.
  *          Then, after loading the containing archive, you can access
  *          [[http://localhost:8080/:syntax?element=https://example.com?T]] to see the whole theory.
  *          To see just the constant, access
  *          [[http://localhost:8080/:syntax?element=https://example.com?T?c]].
  *          In general, this server works for arbitrary MMT [[Path]]s
  *          to view all the outputs added by the diagram feature to the ambient theory graph.
  * @author ComFreek
  */
class SyntaxPresenterServer extends ServerExtension(SyntaxPresenterServer.pathPrefix) {
  final override val logPrefix = pathPrefix

  /**
    * The ''bare.html'' endpoint of the [[https://github.com/ComFreek/mmteditor MMT Online Tools]].
    *
    * It is hosted by default on GitHub pages at [[https://comfreek.github.io/mmteditor/bare.html]].
    * Ask ComFreek if it is ever done or faulty.
    *
    * The string value be safe to interpolate into an HTML attribute enclosed by double quotes.
    */
  private val mmtWebEditorEndpoint: String = "https://comfreek.github.io/mmteditor/bare.html"

  final override def start(args: List[String]): Unit = {
    super.start(args)
  }

  final override def apply(request: ServerRequest): ServerResponse = {
    val elementPath = Path.parse(request.parsedQuery(SyntaxPresenterServer.elementPathKey).getOrElse(
      return ServerResponse.errorResponse(s"missing URI query parameter `${SyntaxPresenterServer.elementPathKey}`")
    ))

    val element = controller.get(elementPath)

    val surfaceSyntax = if (element.feature == InstallDiagram.feature && elementPath.isInstanceOf[MPath]) {
      val outputModules = InstallDiagram.parseOutput(elementPath.asInstanceOf[MPath])(controller.globalLookup).modules
      outputModules.map(controller.get).map(controller.presenter.asString).mkString("")
    } else {
      controller.presenter.asString(element)
    }

    if (request.parsedQuery(SyntaxPresenterServer.plainFlag).isDefined) {
      servePlain(surfaceSyntax)
    } else {
      serveHTML(surfaceSyntax)
    }
  }

  private def servePlain(surfaceSyntax: String): ServerResponse = {
    ServerResponse.fromText(surfaceSyntax)
  }

  private def serveHTML(surfaceSyntax: String): ServerResponse = {
    // Construct HTML
    // Beware of using JSONString multiple times to avoid the infamous pitfalls of naive string interpolation
    // (leading invalid syntax, XSS, SQL Injection, ...).
    val html = s"""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>MMT SyntaxPresenterServer</title>
  </head>
  <style>
    *             { box-sizing: border-box; margin: 0; padding: 0; }
    html, body    { width: 100%; height: 100%; }
    iframe#editor { width: 100%; height: 100%; }
  </style>
  <body>
    <iframe id="editor" src="$mmtWebEditorEndpoint"></iframe>
    <script>
      const mmtSurfaceSyntax = ${JSONString(surfaceSyntax).toCompactString};

      const iframeEditor = document.getElementById("editor");

      // See https://github.com/ComFreek/mmteditor and https://github.com/ComFreek/mmteditor/blob/main/bare.html
      // for the API being used here
      iframeEditor.addEventListener("load", () => {
        iframeEditor.contentWindow.postMessage(
          JSON.stringify({"command": "set-content", "content": mmtSurfaceSyntax}),
          ${JSONString(mmtWebEditorEndpoint)}
        );
      });
    </script>
  </body>
</html>
"""
    ServerResponse.HTMLResponse(html)
  }
}